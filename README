First task: initialzie the heap so I can start allocating memory.
init_heap()
- first call sbrk(0)
    - will return a pointer to the start of teh heap
    - check if that value is divisible by 16
    - if it is, then proceed
    - if not, then make it divisible by 16 by moving the program break to the next location divisible by 16
    (the math for that is (boundary - (current number % boundary)) and then add that to the current boundary)
    (for example, if I wanted to make it aligned to 10 bytes, but I am at 15, I would do (10 - (15 % 10)) which is
    10 - 5 = 5. Then do 15 + 5 = 20, which is the next nearest boundary that is aligned with 10 bytes)
    - make the pointer point there instead of the start of the heap
- make the first sbrk call (sbrk(64KB))
    - create the first header and initialize the fields as NULL and 1 since the chunk is free
    - calculate the chunk size left 
        - 64KB - HEADER_SIZE
        - check if that value is divisible by 16
            - if yes, then continue
            - if not, then round up to the nearest value 
            - set that equal to firstChunk->size

Second task: now write a function that will traverse over the free chunks and check if they are large enough for what we need 
make a struct called ChunkInfo that keeps track of if enough memory was found or not, and a pointer to where that chunk starts
find_free_chunk()
- while the chunk's next pointer is not NULL
    - check if the chunk's size metric is greater than or equal to the chunk size you are looking for
        - if it is, then store a pointer to where that chunk header starts in memory in the struct
            (returning the pointer to the header, will calculate the actual start of usable memory in the malloc function)
    - if the the size you are looking for is not found, then store a 0 in the struct indicating not enough memory was found
- if the next pointer is null, put a 0 in the struct
- return the struct by value not as a pointer so that it gets stored on the stack instead of the heap


Third task: write a function that will go to the chunk with enough space and then split it up
it will take the amount given by the user, and allocate it 
what does "allocate it" mean? It means to take the chunk, and edit the header so that it now says its not free.
also change the size to be the size the user wanted to allocate
then from that header, find the locaation where the new free chunk starts 
do this by making a new pointer point to where the chunk started. 
move this pointer by the amount of bytes the user asked for + the header 
that will take you to where the new chunk starts
at that point, make a new header, implying that you are now creating a new chunk
make that say its free
calculate the new size of that which would be previous chunk size - what the user asked for + sizeof(header)
(might need to store the previous chunk size in another variable so that I can do this math? maybe in a global variable)
not sure what this function returns. 


- function takes in an instance of the chunk info struct
- go to the chunk by looking at the chunk struct region that has the start of chunk pointer that points to the header of that chunk
- change the header so that it is marked as used
- calcualte how much space is left for the new free chunk 
(current chunk size - requested size - sizeof(ChunkHeader))
- change the size field of the struct so that it is the user-requested size
- calculate where the new chunk starts (start_of_chunk_ptr + header + usersize)
- make a new header here 
    - set it to free
    - make the size as the calculated free chunk size - header 
- set the next pointer of the first chunk to point to the start of this new chunk
- set the previous pointer of the next chunk to point to the old chunk 
- return nothing 


another task:
now write a function for if the user asks for more memory, I need to be able to sbrk() for more and create a new header
- call sbrk(64KB) and add more memory
- set all of the chunk's fields
- find what the last chunk is in the current list, and set its next to point to this chunk
- so you have added on a new chunk 
- 




final task for malloc: putting it all together

malloc()
 - first check if the heap exists
    - if it doesn't call initialize_heap()
    - if it does, then go to next step
    - have a int variable act as a flag. 1 for successful memory found, and 0 for not found. 
- while the success flag is not turned on
    - call find free chunk
    - if the chunkInfo->enough_space = 1
    - call splitchunk
    - if splitchunk returns a 0 or a 1, then turn on the success flag
        - return the pointer calculated correctly
    - if it returns a -1, 
        - then keep the success flag off
        - call get more heap
    - if find free chunk chunkInfo->enough_space = 0;
    - call get more heap again 




free()
pseudocode for free:
-check if the pointer given is NULL, if it is then return 
-take in the pointer

find_which_chunk()
-not guaranteed that the pointer points to the start of the ChunkHeader
-it can point to the middle of the chunk too 
-need to start at the global variable for the start of the linked list and traverse through
-check if the pointer given to free is between the start of the last node and the start of the next node 
-that will tell you what chunk the pointer is in 

-now that you know which Chunk, start at the header of that chunk 
-change the header to say that the chunk is now free
3 cases:
-first: current chunk isnt null and one before is free
    -combine those two 
    the prevchunks->prev = curentchunk->prev
-second: current chunk isnt null and one after is free 
    -combine those two 
    the nextchunks->next = currentchunk->next
-third: current chunk isnt null and one before and after are free
    -combine all 3
    prevchunks->prev = curentchunk->prev and nextchunks->next = currentchunk->next
-combine neighboring chunks
-return 

int combine_chunks(chunk1, chunk2)
-return a 0 if the combining did not go well
-return a 1 if the combining happened
-takes in a pointer to the current node 
3 cases:
-first: current chunk and one before is free
    -combine those two 
    -merge their sizes and update in the header
    the prevchunks->prev = curentchunk->prev
-second: current chunk and one after is free 
    -combine those two 
    -merge their sizes and update in the header
    the nextchunks->next = currentchunk->next
-third: current chunk and one before and after are free
    -combine all 3
    -merge their sizes and update in the header
    prevchunks->prev = curentchunk->prev and nextchunks->next = currentchunk->next
-by "combine" I mean to change the pointers so that the point to the right things 












keeping all code on here jsut incase 



    #include "malloc.h"

ChunkHeader *startOfHeap = NULL; 
//global variable to keep track of the very first 
//start of the heap

//function that takes in any integer, checks if 
//it is divisible by 16, if not it will round up 
//until it is possible.
size_t make_16(size_t number){
    while((number % 16) != 0){
        number++;
    }
    return number;
}

void* initialize_heap(){
    startOfHeap = sbrk(0); 
    //tells me where the heap is going to start. 
    //this is the global variable that I am updating
    if(startOfHeap == (void*)-1){ //sbrk returns a 
    //pointer to -1 when it fails
        errno = ENOMEM;
        return NULL;
    }

    //must check if that is divisible by 16  if not I have to 
    //make it that way and move the pointer accordingly
    //cast to an int so I can do math on it 
    uintptr_t mathableAddy = (uintptr_t)startOfHeap;
    if((mathableAddy % 16) != 0){
        uintptr_t byteAdjustment = 16 - (mathableAddy % 16); 
        //gives you how many bytes to move the pointer 
        //forward until its divisible by 16

        printf("byte adjustment: %zu\n", byteAdjustment);

        void* AlignedStartOfHeap = sbrk(byteAdjustment); 
        //move the program break that many bytes forward 
        //until the next multiple of 16

        printf("new aligned start of heap: %p\n", AlignedStartOfHeap);

        if(AlignedStartOfHeap == (void*)-1){ 
            //if the sbrk fails make it error
            errno = ENOMEM;
            return NULL;
        }
    }

    void* firstChunkStart = sbrk(STANDARD_HEAP_SIZE); 
    //first call to sbrk will allocate 64KB of memory
    if(firstChunkStart == (void*)-1){ 
        errno = ENOMEM;
        return NULL;
    }

    printf("First chunk start address: %p\n", firstChunkStart);

    ChunkHeader *firstChunk = (ChunkHeader*)firstChunkStart; 
    //casting the void pointer to a chunkHeader pointer
    //this essentially puts the first node in the chunk of memory 
    //because the start of the memory chunk points to the chunk header
    size_t calculated_size = STANDARD_HEAP_SIZE - CHUNK_HEADER;

    printf("calculated size before making it 16 multiple: %zu\n", calculated_size);

    firstChunk->size = make_16(calculated_size);

    printf("First chunk size (should be divisible by 16): %zu\n", firstChunk->size);

    firstChunk->is_it_free = 1; //yes this chunk is free
    firstChunk->prev = NULL;
    firstChunk->next = NULL;

    //make sure that the fields get assigned properly
    printf("Chunk Header - Address: %p, Size: %zu, Is It Free?: %d\n", (void*)firstChunk, firstChunk->size, firstChunk->is_it_free);

    return firstChunk; 
    //return a pointer to where the first chunk header 
    //starts and / is!
}

ChunkInfo find_free_chunk(ChunkHeader* currentChunk, size_t requestedSize){ 
    //current chunk is the same as the first chunk that gets returned by initialize_heap()
    ChunkInfo chunk_info;

    requestedSize = make_16(requestedSize); 
    //make sure what they ask for is aligned 

    //start off with there is no valid chunk
    chunk_info.enough_space = 0;
    chunk_info.amount_asked_for = 0;
    chunk_info.start_of_free_chunk_ptr = NULL;

    while (currentChunk != NULL){
        if (currentChunk->is_it_free == 1 && currentChunk->size >= requestedSize){ 
            //if its a free chunk and enough space
            chunk_info.enough_space = 1; 
            //yes there is enough space
            chunk_info.start_of_free_chunk_ptr = currentChunk; 
            //so the start of the free chunk gets stored at the start of the header of the free chunk the traversal function found
            chunk_info.amount_asked_for = requestedSize; 
            return chunk_info;
        }
        else{ //else move onto the next chunk
            currentChunk = currentChunk->next;
        }
    }
    return chunk_info;   
    //will have zero and null if nothing is found
}


int split_chunk(ChunkInfo chunk_info){
    ChunkHeader *split_allocated = chunk_info.start_of_free_chunk_ptr; 
    //the allocated chunk will be pointing to where the chunk 
    //that was found as free from the last function's header starts
    split_allocated->is_it_free = 0; 
    //edit that header and make it not free
    //calculate how much free space is left 
    //(current chunk size - requested size - sizeof(ChunkHeader))

    printf("Chunk size: %" PRIu64 "\n", split_allocated->size);
    printf("Requested size (aligned): %" PRIu64 "\n", chunk_info.amount_asked_for);
    printf("Header size: %zu\n", sizeof(ChunkHeader));  

    
    // check if the segment I need is larger than what I have
    if (chunk_info.amount_asked_for + sizeof(ChunkHeader) + 16 > split_allocated->size) {
    // not enough space, the math will go negative and seg fault
        printf("user asked for more than what is available, no splitting. \n");
        return -1; 
    }

    uint64_t user_free_space_left = split_allocated->size - chunk_info.amount_asked_for - sizeof(ChunkHeader);
    printf("FREE SPACE LEFT: %" PRIu64 "\n", user_free_space_left);

    // Check if there is enough space left for another chunk
    if (user_free_space_left <= sizeof(ChunkHeader) + 16) { 
        // +16 is the minimum space to allocate
        printf("REACHING HERE OR NAH\n");
        printf("Not enough space for a new header, using the entire chunk.\n");
        return 0; // Allocate the whole chunk
    }

    //now that I have calculated the amount of free space left for 
    //the user, I can update the header for the size of how much was allocated 
    split_allocated->size = chunk_info.amount_asked_for; //the 
    //size is the aligned amount the user asked for 
    //calculate where the new chunk starts (should be 
    //where the next header starts)
    //next header starts after the amount allocated ends.
    // Make sure that it is lined up with 16 
    uint64_t free_chunk_start = make_16((((uintptr_t)split_allocated) + chunk_info.amount_asked_for + sizeof(ChunkHeader)));
    ChunkHeader* split_free = (ChunkHeader*)free_chunk_start;

    split_free->is_it_free = 1;
    split_free->size = user_free_space_left;
    //make sure the linked list is being constructed properly

    //the free chunk is next and the allocated chunk is first
    split_free->prev = split_allocated;
    split_free->next = split_allocated->next;
    split_allocated->next = split_free;

    // If there's a chunk after the new free chunk its 
    //previous is now split_free and not split_allocated
    if (split_free->next != NULL) {
        split_free->next->prev = split_free; 
        //split_free->next is what used to be the big 
        //chunk's next 
        //so split_free->next->prev is the big chunk's 
        //next's previous (refer to drawing on ipad)
    }

    return 1;
}


void* get_more_heap(){

    void* startOfNewHeap = sbrk(0); 
    //tells me where the new heap chunk will start
    if(startOfNewHeap == (void*)-1){ 
        //sbrk returns a pointer to -1 when it fails
        errno = ENOMEM;
        return NULL;
    }

    printf("new chunk of the heap start address: %p\n", startOfNewHeap);

    //must check if that is divisible by 16  if not I have 
    //to make it that way and move the pointer accordingly
    //cast to an int so I can do math on it 

    uintptr_t mathableNewAddy = (uintptr_t)startOfNewHeap;
    if((mathableNewAddy % 16) != 0){
        uintptr_t byteNewAdjustment = 16 - (mathableNewAddy % 16); 
        //gives you how many bytes to move the pointer 
        //forward until its divisible by 16

        printf("byte adjustment: %zu\n", byteNewAdjustment);

        void* AlignedStartOfNewHeap = sbrk(byteNewAdjustment); 
        //move the program break that many bytes forward 
        //until the next multiple of 16

        printf("new aligned start of heap: %p\n", AlignedStartOfNewHeap);

        if(AlignedStartOfNewHeap == (void*)-1){ 
            //if the sbrk fails make it error
            errno = ENOMEM;
            return NULL;
        }
    }

    void* moreHeapChunkStart = sbrk(STANDARD_HEAP_SIZE); 
    //another call to sbrk will allocate 64KB of memory 
    //and store where the new heap starts
    if(moreHeapChunkStart == (void*)-1){ 
        errno = ENOMEM;
        return NULL;
    }

    //set all of the chunk's fields

    ChunkHeader *newHeapChunk = (ChunkHeader*)moreHeapChunkStart; 
    //casting the void pointer to a chunkHeader pointer
    //this essentially puts the first node in the chunk of 
    //memory because the start of the memory chunk points to the chunk header
    uint64_t new_calculated_size = STANDARD_HEAP_SIZE - CHUNK_HEADER;

    printf("getting more memory, new calculated size: %zu\n", new_calculated_size);

    newHeapChunk->size = make_16(new_calculated_size);

    printf("the new heap chunk's size: %zu\n", newHeapChunk->size);

    newHeapChunk->is_it_free = 1; //yes this chunk is free

    //set the previous pointer to what the last node was 
    //in the list to add it to the linked list properly
    ChunkHeader* current_chunk = startOfHeap;



   if (startOfHeap->next == NULL) { 
    //if there is only one node in the list, then it is the last one. 
        printf("Heap is currently empty, need to add on the new heap to this heap.\n");
        newHeapChunk->prev = startOfHeap;
        startOfHeap->next = newHeapChunk;
        newHeapChunk->next = NULL; 
        //next is NULL since it is now the last in the list
       
    } else {
        while (current_chunk->next != NULL) { 
            printf("BOOB");
            current_chunk = current_chunk->next;  
            //go until the last chunk in the current linked list
        }   //now that the current_chunk is the last one in the list,
        // update the pointers

        newHeapChunk->prev = current_chunk;
        current_chunk->next = newHeapChunk;
        newHeapChunk->next = NULL; //next is NULL since it is now the last in the list
    }

    printf("did it get to the end of get heap\n");
    return newHeapChunk;
}


void* my_malloc(uint64_t requested_amount){
    int successFlag = 0; 
    //starts off as no memory found so not successful
    void* ptr_to_user_memory = NULL;

    requested_amount = make_16(requested_amount); //make sure what they ask for is aligned

    if (startOfHeap == NULL){
        if (initialize_heap() == NULL) {
            return NULL;  //return NULL
        }
    }

    while(successFlag == 0){
        ChunkInfo chunkInfo = find_free_chunk(startOfHeap, requested_amount);

        if (chunkInfo.enough_space == 1){
            int result = split_chunk(chunkInfo);
                if(result == 0 || result == 1){
                    ptr_to_user_memory = (void*)((uintptr_t)chunkInfo.start_of_free_chunk_ptr 
                    + sizeof(ChunkHeader));
                    //where the usable memory starts is where the start of the free chunk pointer + size of the chunk header. 
                    successFlag = 1;
                    return ptr_to_user_memory;  //yay return that to the user
                }
                else if (result == -1){ //not enough space in this chunk to allocate
                    printf("REACHING HERE??\n");
                    //need to use up what is left of the first 
                    //chunk then allocate from the second chunk
                    //can allocate whatevers left of the free chunk
                    uint64_t allocated_already = chunkInfo.start_of_free_chunk_ptr->size;
                    uint64_t left_to_allocate = (requested_amount - allocated_already);


                    printf("Allocated already: %" PRIu64 " bytes, Left to allocate: %" PRIu64 " bytes, 
                    Requested Amount: %" PRIu64 " bytes\n" ,allocated_already, left_to_allocate, requested_amount);

                    chunkInfo.start_of_free_chunk_ptr->is_it_free = 0; 
                    //since that chunk was fully used, mark it as used

                    //grab a new chunk now
                    ChunkHeader* new_heap_chunk = get_more_heap();
                    if (new_heap_chunk == NULL) {
                        return NULL;  //can't get more memory
                    }

                    ChunkInfo newChunkInfo = find_free_chunk(new_heap_chunk, left_to_allocate);
                    int leftoverResult = split_chunk(newChunkInfo);

                    //return the spot in the new chunk where the 
                    //leftover memory was allocated and stopped. 
                    if(leftoverResult == 0 || leftoverResult == 1){
                        ptr_to_user_memory = (void*)((uintptr_t)newChunkInfo.start_of_free_chunk_ptr + sizeof(ChunkHeader));
                        return ptr_to_user_memory;
                    }

                }
        }
        else if (chunkInfo.enough_space == 0){
            ChunkHeader* new_heap_chunk = get_more_heap();
            if (new_heap_chunk == NULL) {
                return NULL;  
            }
        }
    }
    return ptr_to_user_memory;
}