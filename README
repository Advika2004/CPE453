First task: initialzie the heap so I can start allocating memory.
init_heap()
- first call sbrk(0)
    - will return a pointer to the start of teh heap
    - check if that value is divisible by 16
    - if it is, then proceed
    - if not, then make it divisible by 16 by moving the program break to the next location divisible by 16
    (the math for that is (boundary - (current number % boundary)) and then add that to the current boundary)
    (for example, if I wanted to make it aligned to 10 bytes, but I am at 15, I would do (10 - (15 % 10)) which is
    10 - 5 = 5. Then do 15 + 5 = 20, which is the next nearest boundary that is aligned with 10 bytes)
    - make the pointer point there instead of the start of the heap
- make the first sbrk call (sbrk(64KB))
    - create the first header and initialize the fields as NULL and 1 since the chunk is free
    - calculate the chunk size left 
        - 64KB - HEADER_SIZE
        - check if that value is divisible by 16
            - if yes, then continue
            - if not, then round up to the nearest value 
            - set that equal to firstChunk->size

Second task: now write a function that will traverse over the free chunks and check if they are large enough for what we need 
make a struct called ChunkInfo that keeps track of if enough memory was found or not, and a pointer to where that chunk starts
find_free_chunk()
- while the chunk's next pointer is not NULL
    - check if the chunk's size metric is greater than or equal to the chunk size you are looking for
        - if it is, then store a pointer to where that chunk header starts in memory in the struct
            (returning the pointer to the header, will calculate the actual start of usable memory in the malloc function)
    - if the the size you are looking for is not found, then store a 0 in the struct indicating not enough memory was found
- if the next pointer is null, put a 0 in the struct
- return the struct by value not as a pointer so that it gets stored on the stack instead of the heap


Third task: write a function that will go to the chunk with enough space and then split it up
it will take the amount given by the user, and allocate it 
what does "allocate it" mean? It means to take the chunk, and edit the header so that it now says its not free.
also change the size to be the size the user wanted to allocate
then from that header, find the locaation where the new free chunk starts 
do this by making a new pointer point to where the chunk started. 
move this pointer by the amount of bytes the user asked for + the header 
that will take you to where the new chunk starts
at that point, make a new header, implying that you are now creating a new chunk
make that say its free
calculate the new size of that which would be previous chunk size - what the user asked for + sizeof(header)
(might need to store the previous chunk size in another variable so that I can do this math? maybe in a global variable)
not sure what this function returns. 


- function takes in an instance of the chunk info struct
- go to the chunk by looking at the chunk struct region that has the start of chunk pointer that points to the header of that chunk
- change the header so that it is marked as used
- calcualte how much space is left for the new free chunk 
(current chunk size - requested size - sizeof(ChunkHeader))
- change the size field of the struct so that it is the user-requested size
- calculate where the new chunk starts (start_of_chunk_ptr + header + usersize)
- make a new header here 
    - set it to free
    - make the size as the calculated free chunk size - header 
- set the next pointer of the first chunk to point to the start of this new chunk
- set the previous pointer of the next chunk to point to the old chunk 
- return nothing 


another task:
now write a function for if the user asks for more memory, I need to be able to sbrk() for more and create a new header
- call sbrk(64KB) and add more memory
- set all of the chunk's fields
- find what the last chunk is in the current list, and set its next to point to this chunk
- so you have added on a new chunk 
- 




final task for malloc: putting it all together

malloc()
 - first check if the heap exists
    - if it doesn't call initialize_heap()
    - if it does, then go to next step
    - have a int variable act as a flag. 1 for successful memory found, and 0 for not found. 




-- - while the success flag is not turned on
    - call find free chunk
    - if the chunkInfo->enough_space = 1 
        call splitchunk
    - else
        ask more mem
        then split chunk

    -- - if splitchunk returns a 0 or a 1, then turn on the success flag
    --     - return the pointer calculated correctly
    
    
    -- - if it returns a -1, (if not enough space for )
    --     - then keep the success flag off
    --     - call get more heap
    -- - if find free chunk chunkInfo->enough_space = 0;
    -- - call get more heap again 




free()
pseudocode for free:
-check if the pointer given is NULL, if it is then return 
-take in the pointer

find_which_chunk()
-not guaranteed that the pointer points to the start of the ChunkHeader
-it can point to the middle of the chunk too 
-need to start at the global variable for the start of the linked list and traverse through
-check if the pointer given to free is between the start of the last node and the start of the next node 
-that will tell you what chunk the pointer is in 

-now that you know which Chunk, start at the header of that chunk 
-change the header to say that the chunk is now free
3 cases:
-first: current chunk isnt null and one before is free
    -combine those two 
    the prevchunks->prev = curentchunk->prev
-second: current chunk isnt null and one after is free 
    -combine those two 
    the nextchunks->next = currentchunk->next
-third: current chunk isnt null and one before and after are free
    -combine all 3
    prevchunks->prev = curentchunk->prev and nextchunks->next = currentchunk->next
-combine neighboring chunks
-return 

int combine_chunks(chunk1, chunk2)
-return a 0 if the combining did not go well
-return a 1 if the combining happened
-takes in a pointer to the current node 
3 cases:
-first: current chunk and one before is free
    -combine those two 
    -merge their sizes and update in the header
    the prevchunks->prev = curentchunk->prev
-second: current chunk and one after is free 
    -combine those two 
    -merge their sizes and update in the header
    the nextchunks->next = currentchunk->next
-third: current chunk and one before and after are free
    -combine all 3
    -merge their sizes and update in the header
    prevchunks->prev = curentchunk->prev and nextchunks->next = currentchunk->next
-by "combine" I mean to change the pointers so that the point to the right things 

realloc()
pseudocode for reallocating:

-takes in pointer to allocated memory
-takes in new size of how much to allocate 
-if the pointer taken in is NULL
    -just call malloc(new_size)
-if the size given to realloc is 0
    -free the pointer and return NULL
-if the pointer is not null and thesize is not zero
    -check if the new size < current size
    -calculate the current size - new size = leftover space
    -if leftover space > sizeof(header)+16 (the minimum chunk size)
        -make that into a new chunk
        -check if the next chunk is free
        -combine chunks
    -if not, then just leave it
    -adjust the pointers so that the new chunk is added to the linked list
    -find the header of that chunk
    -set its size to be currentsize - new_size
-if the newsize > current size
    -check if the chunk->next is free
    -check if the current chunk + next chunk is large enough
    -if it is, then combine chunks
    -then allocate by modifying the header and changing it to not free
-if its not then get more heap
-copy over the contents with mem move
-free the old chunk
-return a pointer to this new memory











keeping all code on here jsut incase 



    #include "malloc.h"

ChunkHeader *startOfHeap = NULL; 
//global variable to keep track of the very first 
//start of the heap

//function that takes in any integer, checks if 
//it is divisible by 16, if not it will round up 
//until it is possible.
size_t make_16(size_t number){
    while((number % 16) != 0){
        number++;
    }
    return number;
}

void* initialize_heap(){
    startOfHeap = sbrk(0); 
    //tells me where the heap is going to start. 
    //this is the global variable that I am updating
    if(startOfHeap == (void*)-1){ //sbrk returns a 
    //pointer to -1 when it fails
        errno = ENOMEM;
        return NULL;
    }

    //must check if that is divisible by 16  if not I have to 
    //make it that way and move the pointer accordingly
    //cast to an int so I can do math on it 
    uintptr_t mathableAddy = (uintptr_t)startOfHeap;
    if((mathableAddy % 16) != 0){
        uintptr_t byteAdjustment = 16 - (mathableAddy % 16); 
        //gives you how many bytes to move the pointer 
        //forward until its divisible by 16

        printf("byte adjustment: %zu\n", byteAdjustment);

        void* AlignedStartOfHeap = sbrk(byteAdjustment); 
        //move the program break that many bytes forward 
        //until the next multiple of 16

        printf("new aligned start of heap: %p\n", AlignedStartOfHeap);

        if(AlignedStartOfHeap == (void*)-1){ 
            //if the sbrk fails make it error
            errno = ENOMEM;
            return NULL;
        }
    }

    void* firstChunkStart = sbrk(STANDARD_HEAP_SIZE); 
    //first call to sbrk will allocate 64KB of memory
    if(firstChunkStart == (void*)-1){ 
        errno = ENOMEM;
        return NULL;
    }

    printf("First chunk start address: %p\n", firstChunkStart);

    ChunkHeader *firstChunk = (ChunkHeader*)firstChunkStart; 
    //casting the void pointer to a chunkHeader pointer
    //this essentially puts the first node in the chunk of memory 
    //because the start of the memory chunk points to the chunk header
    size_t calculated_size = STANDARD_HEAP_SIZE - CHUNK_HEADER;

    printf("calculated size before making it 16 multiple: %zu\n", calculated_size);

    firstChunk->size = make_16(calculated_size);

    printf("First chunk size (should be divisible by 16): %zu\n", firstChunk->size);

    firstChunk->is_it_free = 1; //yes this chunk is free
    firstChunk->prev = NULL;
    firstChunk->next = NULL;

    //make sure that the fields get assigned properly
    printf("Chunk Header - Address: %p, Size: %zu, Is It Free?: %d\n", (void*)firstChunk, firstChunk->size, firstChunk->is_it_free);

    return firstChunk; 
    //return a pointer to where the first chunk header 
    //starts and / is!
}

ChunkInfo find_free_chunk(ChunkHeader* currentChunk, size_t requestedSize){ 
    //current chunk is the same as the first chunk that gets returned by initialize_heap()
    ChunkInfo chunk_info;

    requestedSize = make_16(requestedSize); 
    //make sure what they ask for is aligned 

    //start off with there is no valid chunk
    chunk_info.enough_space = 0;
    chunk_info.amount_asked_for = 0;
    chunk_info.start_of_free_chunk_ptr = NULL;

    while (currentChunk != NULL){
        if (currentChunk->is_it_free == 1 && currentChunk->size >= requestedSize){ 
            //if its a free chunk and enough space
            chunk_info.enough_space = 1; 
            //yes there is enough space
            chunk_info.start_of_free_chunk_ptr = currentChunk; 
            //so the start of the free chunk gets stored at the start of the header of the free chunk the traversal function found
            chunk_info.amount_asked_for = requestedSize; 
            return chunk_info;
        }
        else{ //else move onto the next chunk
            currentChunk = currentChunk->next;
        }
    }
    return chunk_info;   
    //will have zero and null if nothing is found
}


int split_chunk(ChunkInfo chunk_info){
    ChunkHeader *split_allocated = chunk_info.start_of_free_chunk_ptr; 
    //the allocated chunk will be pointing to where the chunk 
    //that was found as free from the last function's header starts
    split_allocated->is_it_free = 0; 
    //edit that header and make it not free
    //calculate how much free space is left 
    //(current chunk size - requested size - sizeof(ChunkHeader))

    printf("Chunk size: %" PRIu64 "\n", split_allocated->size);
    printf("Requested size (aligned): %" PRIu64 "\n", chunk_info.amount_asked_for);
    printf("Header size: %zu\n", sizeof(ChunkHeader));  

    
    // check if the segment I need is larger than what I have
    if (chunk_info.amount_asked_for + sizeof(ChunkHeader) + 16 > split_allocated->size) {
    // not enough space, the math will go negative and seg fault
        printf("user asked for more than what is available, no splitting. \n");
        return -1; 
    }

    uint64_t user_free_space_left = split_allocated->size - chunk_info.amount_asked_for - sizeof(ChunkHeader);
    printf("FREE SPACE LEFT: %" PRIu64 "\n", user_free_space_left);

    // Check if there is enough space left for another chunk
    if (user_free_space_left <= sizeof(ChunkHeader) + 16) { 
        // +16 is the minimum space to allocate
        printf("REACHING HERE OR NAH\n");
        printf("Not enough space for a new header, using the entire chunk.\n");
        return 0; // Allocate the whole chunk
    }

    //now that I have calculated the amount of free space left for 
    //the user, I can update the header for the size of how much was allocated 
    split_allocated->size = chunk_info.amount_asked_for; //the 
    //size is the aligned amount the user asked for 
    //calculate where the new chunk starts (should be 
    //where the next header starts)
    //next header starts after the amount allocated ends.
    // Make sure that it is lined up with 16 
    uint64_t free_chunk_start = make_16((((uintptr_t)split_allocated) + chunk_info.amount_asked_for + sizeof(ChunkHeader)));
    ChunkHeader* split_free = (ChunkHeader*)free_chunk_start;

    split_free->is_it_free = 1;
    split_free->size = user_free_space_left;
    //make sure the linked list is being constructed properly

    //the free chunk is next and the allocated chunk is first
    split_free->prev = split_allocated;
    split_free->next = split_allocated->next;
    split_allocated->next = split_free;

    // If there's a chunk after the new free chunk its 
    //previous is now split_free and not split_allocated
    if (split_free->next != NULL) {
        split_free->next->prev = split_free; 
        //split_free->next is what used to be the big 
        //chunk's next 
        //so split_free->next->prev is the big chunk's 
        //next's previous (refer to drawing on ipad)
    }

    return 1;
}


void* get_more_heap(){

    void* startOfNewHeap = sbrk(0); 
    //tells me where the new heap chunk will start
    if(startOfNewHeap == (void*)-1){ 
        //sbrk returns a pointer to -1 when it fails
        errno = ENOMEM;
        return NULL;
    }

    printf("new chunk of the heap start address: %p\n", startOfNewHeap);

    //must check if that is divisible by 16  if not I have 
    //to make it that way and move the pointer accordingly
    //cast to an int so I can do math on it 

    uintptr_t mathableNewAddy = (uintptr_t)startOfNewHeap;
    if((mathableNewAddy % 16) != 0){
        uintptr_t byteNewAdjustment = 16 - (mathableNewAddy % 16); 
        //gives you how many bytes to move the pointer 
        //forward until its divisible by 16

        printf("byte adjustment: %zu\n", byteNewAdjustment);

        void* AlignedStartOfNewHeap = sbrk(byteNewAdjustment); 
        //move the program break that many bytes forward 
        //until the next multiple of 16

        printf("new aligned start of heap: %p\n", AlignedStartOfNewHeap);

        if(AlignedStartOfNewHeap == (void*)-1){ 
            //if the sbrk fails make it error
            errno = ENOMEM;
            return NULL;
        }
    }

    void* moreHeapChunkStart = sbrk(STANDARD_HEAP_SIZE); 
    //another call to sbrk will allocate 64KB of memory 
    //and store where the new heap starts
    if(moreHeapChunkStart == (void*)-1){ 
        errno = ENOMEM;
        return NULL;
    }

    //set all of the chunk's fields

    ChunkHeader *newHeapChunk = (ChunkHeader*)moreHeapChunkStart; 
    //casting the void pointer to a chunkHeader pointer
    //this essentially puts the first node in the chunk of 
    //memory because the start of the memory chunk points to the chunk header
    uint64_t new_calculated_size = STANDARD_HEAP_SIZE - CHUNK_HEADER;

    printf("getting more memory, new calculated size: %zu\n", new_calculated_size);

    newHeapChunk->size = make_16(new_calculated_size);

    printf("the new heap chunk's size: %zu\n", newHeapChunk->size);

    newHeapChunk->is_it_free = 1; //yes this chunk is free

    //set the previous pointer to what the last node was 
    //in the list to add it to the linked list properly
    ChunkHeader* current_chunk = startOfHeap;



   if (startOfHeap->next == NULL) { 
    //if there is only one node in the list, then it is the last one. 
        printf("Heap is currently empty, need to add on the new heap to this heap.\n");
        newHeapChunk->prev = startOfHeap;
        startOfHeap->next = newHeapChunk;
        newHeapChunk->next = NULL; 
        //next is NULL since it is now the last in the list
       
    } else {
        while (current_chunk->next != NULL) { 
            printf("BOOB");
            current_chunk = current_chunk->next;  
            //go until the last chunk in the current linked list
        }   //now that the current_chunk is the last one in the list,
        // update the pointers

        newHeapChunk->prev = current_chunk;
        current_chunk->next = newHeapChunk;
        newHeapChunk->next = NULL; //next is NULL since it is now the last in the list
    }

    printf("did it get to the end of get heap\n");
    return newHeapChunk;
}


void* my_malloc(uint64_t requested_amount){
    int successFlag = 0; 
    //starts off as no memory found so not successful
    void* ptr_to_user_memory = NULL;

    requested_amount = make_16(requested_amount); //make sure what they ask for is aligned

    if (startOfHeap == NULL){
        if (initialize_heap() == NULL) {
            return NULL;  //return NULL
        }
    }

    while(successFlag == 0){
        ChunkInfo chunkInfo = find_free_chunk(startOfHeap, requested_amount);

        if (chunkInfo.enough_space == 1){
            int result = split_chunk(chunkInfo);
                if(result == 0 || result == 1){
                    ptr_to_user_memory = (void*)((uintptr_t)chunkInfo.start_of_free_chunk_ptr 
                    + sizeof(ChunkHeader));
                    //where the usable memory starts is where the start of the free chunk pointer + size of the chunk header. 
                    successFlag = 1;
                    return ptr_to_user_memory;  //yay return that to the user
                }
                else if (result == -1){ //not enough space in this chunk to allocate
                    printf("REACHING HERE??\n");
                    //need to use up what is left of the first 
                    //chunk then allocate from the second chunk
                    //can allocate whatevers left of the free chunk
                    uint64_t allocated_already = chunkInfo.start_of_free_chunk_ptr->size;
                    uint64_t left_to_allocate = (requested_amount - allocated_already);


                    printf("Allocated already: %" PRIu64 " bytes, Left to allocate: %" PRIu64 " bytes, 
                    Requested Amount: %" PRIu64 " bytes\n" ,allocated_already, left_to_allocate, requested_amount);

                    chunkInfo.start_of_free_chunk_ptr->is_it_free = 0; 
                    //since that chunk was fully used, mark it as used

                    //grab a new chunk now
                    ChunkHeader* new_heap_chunk = get_more_heap();
                    if (new_heap_chunk == NULL) {
                        return NULL;  //can't get more memory
                    }

                    ChunkInfo newChunkInfo = find_free_chunk(new_heap_chunk, left_to_allocate);
                    int leftoverResult = split_chunk(newChunkInfo);

                    //return the spot in the new chunk where the 
                    //leftover memory was allocated and stopped. 
                    if(leftoverResult == 0 || leftoverResult == 1){
                        ptr_to_user_memory = (void*)((uintptr_t)newChunkInfo.start_of_free_chunk_ptr + sizeof(ChunkHeader));
                        return ptr_to_user_memory;
                    }

                }
        }
        else if (chunkInfo.enough_space == 0){
            ChunkHeader* new_heap_chunk = get_more_heap();
            if (new_heap_chunk == NULL) {
                return NULL;  
            }
        }
    }
    return ptr_to_user_memory;
}




// void print_heap() {
    //     ChunkHeader *current_chunk = startOfHeap;
    
    //     if (current_chunk == NULL) {
    //         snprintf(buf, BUFFER_SIZE, "Heap is empty.\n");
    //         write(STDOUT_FILENO, buf, strlen(buf));
    //         return;
    //     }
    
    //     snprintf(buf, BUFFER_SIZE, "Heap structure:\n");
    //     write(STDOUT_FILENO, buf, strlen(buf));
    
    //     // Iterate through all chunks in the heap
    //     while (current_chunk != NULL) {
    //         // Print the chunk's memory address, size, and whether it's free or not
    //         snprintf(buf, BUFFER_SIZE,
    //                  "Chunk at address: %p\n  Size: %zu bytes\n  Is free: %d\n",
    //                  (void*)current_chunk, current_chunk->size, 
    //                  current_chunk->is_it_free);
    //         write(STDOUT_FILENO, buf, strlen(buf));
    
    //         // Move to the next chunk in the heap
    //         current_chunk = current_chunk->next;
    //     }
    
    //     snprintf(buf, BUFFER_SIZE, "End of heap.\n");
    //     write(STDOUT_FILENO, buf, strlen(buf));
    // }

    // //recursive function to keep allocating what is left over
        // void* allocate_leftover(size_t left_to_allocate) {
        
        //     //allocate a new chunk
        //     ChunkHeader* new_heap_chunk = get_more_heap();
        
        //     //check if that fails
        //     if (new_heap_chunk == NULL) {
        //         return NULL;
        //     }
        
        //     //try to fit the remaining data in the new chunk
        //     ChunkInfo newChunkInfo = find_free_chunk(new_heap_chunk, left_to_allocate);
        //     int leftoverResult = split_chunk(newChunkInfo);
        
        //     // if it fits, return the pointer to the allocated space
        //     if (leftoverResult == 0 || leftoverResult == 1) {
        //         return (void*)((uintptr_t)newChunkInfo.start_of_free_chunk_ptr 
        //         + sizeof(ChunkHeader));
        //     }
        
        //     //still not enough space, recursively allocate again until enough space
        //     if (leftoverResult == -1) {
        //         // Calculate how much is left to allocate after using this chunk
        //         size_t allocated_already = newChunkInfo.start_of_free_chunk_ptr->size;
        //         size_t new_left_to_allocate = left_to_allocate - allocated_already;
        
        //         //call allocate_leftover for the remaining space
        //         return allocate_leftover(new_left_to_allocate);
        //     }
        //     //should never reach here
        //     return NULL;
        // }




        void* realloc(void* ptr, size_t new_size){

            //make sure the new size is aligned too
            new_size = make_16(new_size);
        
            ChunkHeader* reallocked_ptr = NULL;
            
            //check if the pointer given is NULL just call malloc
            if(ptr == NULL){
                reallocked_ptr = malloc(new_size);
                return reallocked_ptr;
            }
        
            //check if the size given is zero
            if(new_size == 0){
                free(ptr);
                return NULL;
            }
        
            //if the pointer is not null and the size is not zero can truly realloc
            if((ptr != NULL) && (new_size != 0)){
        
                //need to calculate where the header starts
                ChunkHeader* theHeaderStarts;
                uintptr_t mathableAddy = (uintptr_t)ptr;
        
                //go backwards by the size of the chunk header to find the header
                //get the size of that chunk
                theHeaderStarts = (ChunkHeader*)(mathableAddy - sizeof(ChunkHeader));
                size_t current_chunk_size = theHeaderStarts->size;
        
                //SHRINKING: 
                //case 1: new size is smaller than current chunk size
                //allocate what I need by updating the header
                //make the leftover space into its own node
                //combine it with other free stuff
                //return pointer to where data starts 
        
                if(new_size < current_chunk_size){
                    theHeaderStarts->size = new_size;
                    theHeaderStarts->is_it_free = 0;
        
                    //find how much the leftover space is
                    //make that into a new chunk
                    //calculate where the leftover chunk starts
                    size_t leftover_space = current_chunk_size - new_size;
        
                    //if the leftover space is big enough to make a chunk out of
                    if(leftover_space >= sizeof(ChunkHeader) + 16){
                        ChunkHeader* leftover_free_chunk_header = (ChunkHeader*)
                        ((uintptr_t)theHeaderStarts 
                        + new_size);
        
                        //check if the one after that is free too
                        if(leftover_free_chunk_header->next->is_it_free == 1){
                            leftover_free_chunk_header = 
                            combine_free_chunks(leftover_free_chunk_header);
                        }
        
                        //if the next one is not free, just leave this free chunk alone
                        //add new broken off chunk to the linked list and fill fields
                        leftover_free_chunk_header->next = theHeaderStarts->next;
                        theHeaderStarts->next->prev = leftover_free_chunk_header;
                        leftover_free_chunk_header->prev = theHeaderStarts;
                        leftover_free_chunk_header->is_it_free = 1; 
                        leftover_free_chunk_header->size = leftover_space - 
                        sizeof(ChunkHeader);
        
                        //reallocked pointer is where the reallocked data starts 
                        void* reallocked_data_starts = 
                        (void*)((uintptr_t)theHeaderStarts + sizeof(ChunkHeader));
                        reallocked_ptr = reallocked_data_starts;
                    }
                    //if the leftover chunk is not big enough to do anything with
                    //do not combine chunks, and instead grab more memory/
                    //need to allocate more
                    else{
                        ChunkHeader* gotnewChunk = malloc(new_size);
        
                        //check if mallocking that failed
                        if(gotnewChunk == NULL){
                            reallocked_ptr = NULL;
                        }
        
                        memmove(gotnewChunk, ptr, current_chunk_size);
        
                        free(ptr);
        
                        reallocked_ptr = gotnewChunk;
        
                    } 
                }
        
        
                //DO NOTHING:
                //it is the same size so just return the same pointer
                if(new_size == current_chunk_size){
                    reallocked_ptr = ptr;
                }
        
                //GROWING:
                //new size is larger than current and the next one is free
                //and that is large enough
                //combine the chunks, allocate what you need
                //make new chunk with leftover
                //check if other is free next to it
                //combine that too
                //return pointer to first node
                else if (new_size > current_chunk_size){
                    
                    //check if the next chunk is free and not NULL
                    ChunkHeader* nextdoorChunk = theHeaderStarts->next;
                    if(nextdoorChunk != NULL && nextdoorChunk->is_it_free == 0){
                        //check if combining them will make it large enough
                        //then allocate it
                        if((current_chunk_size + nextdoorChunk->size + 
                        sizeof(ChunkHeader)) >= new_size){
                            combine_free_chunks(theHeaderStarts);
                            theHeaderStarts->is_it_free = 0;
                            theHeaderStarts->next = nextdoorChunk->next;
                            theHeaderStarts->size = (current_chunk_size 
                            + nextdoorChunk->size + sizeof(ChunkHeader));
                        }
        
                        //if combining them was large enough, theres some leftover
                        //need to make that into a new chunk just like above 
        
                        size_t leftover_space = (current_chunk_size + 
                        nextdoorChunk->size + sizeof(ChunkHeader)) - new_size;
        
                        if(leftover_space >= sizeof(ChunkHeader) + 16){
                        ChunkHeader* leftover_free_chunk_header = (ChunkHeader*)
                        ((uintptr_t)theHeaderStarts 
                        + new_size);
        
                        //check if the one after that is free too
                        //make into one large chunk and store that as leftover chunk
                        if(leftover_free_chunk_header->next->is_it_free == 1){
                            leftover_free_chunk_header = 
                            combine_free_chunks(leftover_free_chunk_header);
                        }
        
                        //if the next one is not free, just leave this free chunk alone
                        //add new broken off chunk to the linked list and fill fields
                        leftover_free_chunk_header->next = theHeaderStarts->next;
                        theHeaderStarts->next->prev = leftover_free_chunk_header;
                        leftover_free_chunk_header->prev = theHeaderStarts;
                        leftover_free_chunk_header->is_it_free = 1; 
                        leftover_free_chunk_header->size = leftover_space - 
                        sizeof(ChunkHeader);
        
                        //reallocked pointer is where the reallocked data starts 
                        void* reallocked_data_starts = (void*)((uintptr_t)theHeaderStarts 
                        + sizeof(ChunkHeader));
                        reallocked_ptr = reallocked_data_starts;
        
                        }
        
                        //if the leftover space is too small to make a new chunk
                        //go grab more memory
                        else{
                            ChunkHeader* gotnewChunk = malloc(new_size);
        
                            //check if mallocking that failed
                            if(gotnewChunk == NULL){
                                reallocked_ptr = NULL;
                            }
        
                            memmove(gotnewChunk, ptr, current_chunk_size);
        
                            free(ptr);
        
                            reallocked_ptr = gotnewChunk;
                        }
                    }
        
                        //if next chunk is NULL
                        //go grab more memory
                        if(nextdoorChunk == NULL){
                            ChunkHeader* gotnewChunk = malloc(new_size);
        
                            //check if mallocking that failed
                            if(gotnewChunk == NULL){
                                reallocked_ptr = NULL;
                            }
        
                            memmove(gotnewChunk, ptr, current_chunk_size);
        
                            free(ptr);
        
                            reallocked_ptr = gotnewChunk; 
                        }
        
                        //if combining them will not make it bigger, then get more mem
                        //copy stuff over
                        //free the old chunk
                        else{
                            ChunkHeader* gotnewChunk = malloc(new_size);
        
                            //check if mallocking that failed
                            if(gotnewChunk == NULL){
                                reallocked_ptr = NULL;
                            }
        
                            memmove(gotnewChunk, ptr, current_chunk_size);
        
                            free(ptr);
        
                            reallocked_ptr = gotnewChunk;
                        }
                }
            }
            return reallocked_ptr;
        }



        int split_chunk(ChunkInfo chunk_info){
            //current free chunk will be allocated
            //edit that header and make it not free
            ChunkHeader *split_allocated = chunk_info.start_of_free_chunk_ptr;  
           
            // check if user asks for more than I have
            // not enough space, return -1
            // do not allocate anything right now
            // this case will be handled in the malloc
            if (chunk_info.amount_asked_for + sizeof(ChunkHeader) 
            + 16 > split_allocated->size) {
                return -1; 
            }
        
            //calculate how much free space is left 
            //(current chunk size - requested size - sizeof(ChunkHeader)) + 16
            size_t user_free_space_left = split_allocated->size 
                                          - chunk_info.amount_asked_for 
                                          - sizeof(ChunkHeader);
        
        
            //if not enough in the free chunk for user to use with min amount
            //mark entire chunk as allocated
            if (user_free_space_left <= sizeof(ChunkHeader) + 16){
                split_allocated->size = chunk_info.amount_asked_for;
                split_allocated->is_it_free = 0; 
                return 0; //not split, whole chunk used
            }
        
            //if there is enough space, then allocate the chunk and split it
            split_allocated->size = chunk_info.amount_asked_for;
            split_allocated->is_it_free = 0;
        
            //calculate where new chunk starts (should be where next header starts)
            //next header starts after the amount allocated ends.
            //make sure that it is lined up with 16 
            //make new node
            size_t free_chunk_start = make_16((((uintptr_t)split_allocated) 
            + chunk_info.amount_asked_for + sizeof(ChunkHeader)));
            ChunkHeader* split_free = (ChunkHeader*)free_chunk_start;
        
            //new node is free
            //user space left was calculated above
            split_free->is_it_free = 1;
            split_free->size = user_free_space_left;
        
            //the free chunk is next and the allocated chunk is first
            split_free->prev = split_allocated;
            split_free->next = split_allocated->next;
            split_allocated->next = split_free;
        
            // If there's a chunk after the new free chunk..
            //its previous is now split_free and not split_allocated
            //split_free->next is what used to be the big chunk's next 
            //so split_free->next->prev is the big chunk's next's previous
            // (refer to drawing on ipad)
            if (split_free->next != NULL) {
                split_free->next->prev = split_free; 
            }
        
            return 1; //it was split
        }
        
        void* get_more_heap(size_t amount_to_allocate){
        
            //tells me where the new heap chunk will start
            void* startOfNewHeap = sbrk(0); 
        
            //check if it fails
            if(startOfNewHeap == (void*)-1){ 
                errno = ENOMEM;
                return NULL;
            }
        
            //check if aligned
            //if not do same as init heap
            //make it mathable then adjust pointer
            uintptr_t mathableNewAddy = (uintptr_t)startOfNewHeap;
            if((mathableNewAddy % 16) != 0){
                uintptr_t byteNewAdjustment = 16 - (mathableNewAddy % 16); 
        
                //move the program break that many bytes forward 
                //until the next multiple of 16
                void* AlignedStartOfNewHeap = sbrk(byteNewAdjustment); 
        
                //if the sbrk fails make it error
                if(AlignedStartOfNewHeap == (void*)-1){ 
                    errno = ENOMEM;
                    return NULL;
                }
            }
        
            //another call to sbrk will allocate 64KB of memory 
            //pointer will store where the new heap starts
            void* moreHeapChunkStart = sbrk(amount_to_allocate);
        
            //check if it fails
            if(moreHeapChunkStart == (void*)-1){ 
                errno = ENOMEM;
                return NULL;
            }
            
            //casting the void pointer to a chunkHeader pointer
            //puts the first node in the chunk of memory 
            //find how much more memory the user can have
            ChunkHeader *newHeapChunk = (ChunkHeader*)moreHeapChunkStart; 
            size_t new_calculated_size = amount_to_allocate - CHUNK_HEADER;
        
            //make sure it is aligned
            newHeapChunk->size = make_16(new_calculated_size);
        
            //yes this chunk is free
            newHeapChunk->is_it_free = 1; 
        
            //use the global variable to find the first node in linked list
            ChunkHeader* current_chunk = startOfHeap;
        
        
            //if there is only one node in the list, then it is the last one.
            //next of the new chunk is NULL since it is now the last in the list
            if (startOfHeap->next == NULL) {  
                newHeapChunk->prev = startOfHeap;
                startOfHeap->next = newHeapChunk;
                newHeapChunk->next = NULL; 
            } 
        
            //go until the last chunk in the current linked list
            //adjust the pointers to add the new chunk to the end
            else {
                while (current_chunk->next != NULL) { 
                    current_chunk = current_chunk->next;  
                }  
                newHeapChunk->prev = current_chunk;
                current_chunk->next = newHeapChunk;
                newHeapChunk->next = NULL; 
            }
        
            return newHeapChunk;
        }
        
        
        void* malloc(size_t requested_amount){
        
            //check if malloc is linking and running
            // snprintf(buf, BUFFER_SIZE, "Calling malloc succeeded:\n");
            // write(STDOUT_FILENO, buf, strlen(buf));
        
            //starts off as no memory found so not successful
        
            //what malloc will return eventually
            void* ptr_to_user_memory = NULL;
        
            //make sure what they ask for is aligned
            requested_amount = make_16(requested_amount);
        
            // snprintf(buf, BUFFER_SIZE, 
            // "Requested amount (aligned to 16): %zu\n", requested_amount);
            // write(STDOUT_FILENO, buf, strlen(buf));
        
            //if there is no chunk yet, make one
            if (startOfHeap == NULL){
        
                // snprintf(buf, BUFFER_SIZE, "Initializing heap.\n");
                // write(STDOUT_FILENO, buf, strlen(buf));
        
                initialize_heap();
            }
        
            //while there is no memory found for the user to use
            //traverse and find a free node
                // snprintf(buf, BUFFER_SIZE, "Finding free chunk.\n");
                // write(STDOUT_FILENO, buf, strlen(buf));
        
                ChunkInfo chunkInfo = find_free_chunk(startOfHeap, requested_amount);
        
                //if a big enough chunk is found
                if (chunkInfo.enough_space == 1){
        
                    // snprintf(buf, BUFFER_SIZE, "Found a chunk with enough space.\n");
                    // write(STDOUT_FILENO, buf, strlen(buf));
        
                    //then split that chunk up into allocated and what's free left over
                    int result = split_chunk(chunkInfo);
        
                    //if the whole chunk was allocated
                    //need to grab a new chunk and return the start of that to user
                    if (result == 0) {
        
                        // snprintf(buf, BUFFER_SIZE, 
                        // "Entire chunk allocated. Getting more heap.\n");
                        // write(STDOUT_FILENO, buf, strlen(buf));
        
                        //allocate a new chunk
                        ChunkHeader* got_more_chunk = get_more_heap(STANDARD_HEAP_SIZE);
            
                        //check if that fails
                        if (got_more_chunk == NULL) {
        
                            // snprintf(buf, BUFFER_SIZE, 
                            // "Error: Could not allocate more memory.\n");
                            // write(STDOUT_FILENO, buf, strlen(buf));
        
                            return NULL;
                        }
        
                        //return start of the new chunk's usable memory (after header)
                        //it was successfully mallocked
                        //return ptr to user
                        ptr_to_user_memory = (void*)((uintptr_t)got_more_chunk 
                        + sizeof(ChunkHeader));
        
                        // snprintf(buf, BUFFER_SIZE, 
                        // "Returning new chunk pointer: %p\n", ptr_to_user_memory);
                        // write(STDOUT_FILENO, buf, strlen(buf));
        
                        return ptr_to_user_memory;
                    } 
                    
                    //if the chunk was split up and allocated
                    //return pointer to the split_free header
                    else if (result == 1) {
        
                        // snprintf(buf, BUFFER_SIZE, 
                        // "Chunk split successfully. Allocating memory.\n");
                        // write(STDOUT_FILENO, buf, strlen(buf));
        
                        ptr_to_user_memory = (void*)((uintptr_t)
                        chunkInfo.start_of_free_chunk_ptr + sizeof(ChunkHeader));
        
                        // snprintf(buf, BUFFER_SIZE, 
                        // "Returning pointer after split: %p\n", ptr_to_user_memory);
                        // write(STDOUT_FILENO, buf, strlen(buf));
        
                        return ptr_to_user_memory;  // Return that to the user
                    }
        
                    //need to allocate more and split
                    //If no chunk had enough space (enough_space == 0) 
                    //or if the result was -1 (nothing was allocated bc too small)
                    else if (chunkInfo.enough_space == 0 || result == -1) {
        
                        // snprintf(buf, BUFFER_SIZE, 
                        // "Not enough space in current chunk. new chunk.\n");
                        // write(STDOUT_FILENO, buf, strlen(buf));
        
                        //allocate the entire thing
                        //calculate how much spills over for the new chunk
                        size_t allocated_already = 
                        chunkInfo.start_of_free_chunk_ptr->size;
                        size_t left_to_allocate = requested_amount - allocated_already;
        
                        // snprintf(buf, BUFFER_SIZE, 
                        // "Allocated already: %zu, Left to allocate: %zu\n", 
                        // allocated_already, left_to_allocate);
                        // write(STDOUT_FILENO, buf, strlen(buf));
                    
                        //say current chunk is fully used
                        chunkInfo.start_of_free_chunk_ptr->is_it_free = 0; 
        
                        //call allocate leftover to allocate what is left
                        ChunkHeader* leftover_ptr = get_more_heap(left_to_allocate
                         + sizeof(ChunkHeader));
        
                        //successful, return the pointer
                        if (leftover_ptr == NULL) {
                            return NULL;
                        }
        
                            ptr_to_user_memory = leftover_ptr;
        
                            // snprintf(buf, BUFFER_SIZE, 
                            // "Allocated leftover memory. Returning pointer: %p\n",
                            //  ptr_to_user_memory);
                            // write(STDOUT_FILENO, buf, strlen(buf));
        
                            return ptr_to_user_memory;
                    }
                }
                   
            return ptr_to_user_memory;
        }
        
        
        void* realloc(void* ptr, size_t new_size){
        
                    //make sure the new size is aligned too
                    new_size = make_16(new_size);
                
                    ChunkHeader* reallocked_ptr = NULL;
                    
                    //check if the pointer given is NULL just call malloc
                    if(ptr == NULL){
                        reallocked_ptr = malloc(new_size);
                        return reallocked_ptr;
                    }
                
                    //check if the size given is zero
                    if(new_size == 0){
                        free(ptr);
                        return NULL;
                    }
                
                    //if the pointer is not null and the size is not zero can truly realloc
                    if((ptr != NULL) && (new_size != 0)){
                
                        //need to calculate where the header starts
                        ChunkHeader* theHeaderStarts;
                        uintptr_t mathableAddy = (uintptr_t)ptr;
                
                        //go backwards by the size of the chunk header to find the header
                        //get the size of that chunk
                        theHeaderStarts = (ChunkHeader*)(mathableAddy - sizeof(ChunkHeader));
                        size_t current_chunk_size = theHeaderStarts->size;
                
                        //SHRINKING: 
                        //case 1: new size is smaller than current chunk size
                        //allocate what I need by updating the header
                        //make the leftover space into its own node
                        //combine it with other free stuff
                        //return pointer to where data starts 
                
                        if(new_size < current_chunk_size){
                            theHeaderStarts->size = new_size;
                            theHeaderStarts->is_it_free = 0;
                
                            //find how much the leftover space is
                            //make that into a new chunk
                            //calculate where the leftover chunk starts
                            size_t leftover_space = current_chunk_size - new_size;
                
                            //if the leftover space is big enough to make a chunk out of
                            if(leftover_space >= sizeof(ChunkHeader) + 16){
                                ChunkHeader* leftover_free_chunk_header = (ChunkHeader*)
                                ((uintptr_t)theHeaderStarts 
                                + new_size);
                
                                //check if the one after that is free too
                                if(leftover_free_chunk_header->next->is_it_free == 1){
                                    leftover_free_chunk_header = 
                                    combine_free_chunks(leftover_free_chunk_header);
                                }
                
                                //if the next one is not free, just leave this free chunk alone
                                //add new broken off chunk to the linked list and fill fields
                                leftover_free_chunk_header->next = theHeaderStarts->next;
                                theHeaderStarts->next->prev = leftover_free_chunk_header;
                                leftover_free_chunk_header->prev = theHeaderStarts;
                                leftover_free_chunk_header->is_it_free = 1; 
                                leftover_free_chunk_header->size = leftover_space - 
                                sizeof(ChunkHeader);
                
                                //reallocked pointer is where the reallocked data starts 
                                void* reallocked_data_starts = 
                                (void*)((uintptr_t)theHeaderStarts + sizeof(ChunkHeader));
                                reallocked_ptr = reallocked_data_starts;
                            }
                            //if the leftover chunk is not big enough to do anything with
                            //do not combine chunks, and instead grab more memory/
                            //need to allocate more
                            else{
                                ChunkHeader* gotnewChunk = malloc(new_size);
                
                                //check if mallocking that failed
                                if(gotnewChunk == NULL){
                                    reallocked_ptr = NULL;
                                }
                
                                memmove(gotnewChunk, ptr, current_chunk_size);
                
                                free(ptr);
                
                                reallocked_ptr = gotnewChunk;
                
                            } 
                        }
                
                
                        //DO NOTHING:
                        //it is the same size so just return the same pointer
                        if(new_size == current_chunk_size){
                            reallocked_ptr = ptr;
                        }
                
                        //GROWING:
                        //new size is larger than current and the next one is free
                        //and that is large enough
                        //combine the chunks, allocate what you need
                        //make new chunk with leftover
                        //check if other is free next to it
                        //combine that too
                        //return pointer to first node
                        else if (new_size > current_chunk_size){
                            
                            //check if the next chunk is free and not NULL
                            ChunkHeader* nextdoorChunk = theHeaderStarts->next;
                            if(nextdoorChunk != NULL && nextdoorChunk->is_it_free == 0){
                                //check if combining them will make it large enough
                                //then allocate it
                                if((current_chunk_size + nextdoorChunk->size + 
                                sizeof(ChunkHeader)) >= new_size){
                                    combine_free_chunks(theHeaderStarts);
                                    theHeaderStarts->is_it_free = 0;
                                    theHeaderStarts->next = nextdoorChunk->next;
                                    theHeaderStarts->size = (current_chunk_size 
                                    + nextdoorChunk->size + sizeof(ChunkHeader));
                                }
                
                                //if combining them was large enough, theres some leftover
                                //need to make that into a new chunk just like above 
                
                                size_t leftover_space = (current_chunk_size + 
                                nextdoorChunk->size + sizeof(ChunkHeader)) - new_size;
                
                                if(leftover_space >= sizeof(ChunkHeader) + 16){
                                ChunkHeader* leftover_free_chunk_header = (ChunkHeader*)
                                ((uintptr_t)theHeaderStarts 
                                + new_size);
                
                                //check if the one after that is free too
                                //make into one large chunk and store that as leftover chunk
                                if(leftover_free_chunk_header->next->is_it_free == 1){
                                    leftover_free_chunk_header = 
                                    combine_free_chunks(leftover_free_chunk_header);
                                }
                
                                //if the next one is not free, just leave this free chunk alone
                                //add new broken off chunk to the linked list and fill fields
                                leftover_free_chunk_header->next = theHeaderStarts->next;
                                theHeaderStarts->next->prev = leftover_free_chunk_header;
                                leftover_free_chunk_header->prev = theHeaderStarts;
                                leftover_free_chunk_header->is_it_free = 1; 
                                leftover_free_chunk_header->size = leftover_space - 
                                sizeof(ChunkHeader);
                
                                //reallocked pointer is where the reallocked data starts 
                                void* reallocked_data_starts = (void*)((uintptr_t)theHeaderStarts 
                                + sizeof(ChunkHeader));
                                reallocked_ptr = reallocked_data_starts;
                
                                }
                
                                //if the leftover space is too small to make a new chunk
                                //go grab more memory
                                else{
                                    ChunkHeader* gotnewChunk = malloc(new_size);
                
                                    //check if mallocking that failed
                                    if(gotnewChunk == NULL){
                                        reallocked_ptr = NULL;
                                    }
                
                                    memmove(gotnewChunk, ptr, current_chunk_size);
                
                                    free(ptr);
                
                                    reallocked_ptr = gotnewChunk;
                                }
                            }
                
                                //if next chunk is NULL
                                //go grab more memory
                                if(nextdoorChunk == NULL){
                                    ChunkHeader* gotnewChunk = malloc(new_size);
                
                                    //check if mallocking that failed
                                    if(gotnewChunk == NULL){
                                        reallocked_ptr = NULL;
                                    }
                
                                    memmove(gotnewChunk, ptr, current_chunk_size);
                
                                    free(ptr);
                
                                    reallocked_ptr = gotnewChunk; 
                                }
                
                                //if combining them will not make it bigger, then get more mem
                                //copy stuff over
                                //free the old chunk
                                else{
                                    ChunkHeader* gotnewChunk = malloc(new_size);
                
                                    //check if mallocking that failed
                                    if(gotnewChunk == NULL){
                                        reallocked_ptr = NULL;
                                    }
                
                                    memmove(gotnewChunk, ptr, current_chunk_size);
                
                                    free(ptr);
                
                                    reallocked_ptr = gotnewChunk;
                                }
                        }
                    }
                    return reallocked_ptr;
                }




realloc is here:
void* realloc(void* ptr, size_t new_size){

    //make sure the new size wanted is aligned
    new_size = make_16(new_size);

    //check if the pointer given is NULL just call malloc
    if(ptr == NULL){
        return malloc(new_size);
    }
        
    //check if the size given is zero
    if(new_size == 0){
        free(ptr);
        return NULL;
    }

    //need to calculate where the header starts
    ChunkHeader* theHeaderStarts;
    uintptr_t mathableAddy = (uintptr_t)ptr;

    //go backwards by the size of the chunk header to find the header
    //get the size of that chunk
    theHeaderStarts = (ChunkHeader*)(mathableAddy - sizeof(ChunkHeader));
    size_t current_chunk_size = theHeaderStarts->size;

    //SHRINKING: 
    //case 1: new size is smaller than current chunk size
    //allocate what I need by updating the header
    //make the leftover space into its own node
    //combine it with other free stuff
    //return pointer to where data starts 

    if(new_size < current_chunk_size){


        theHeaderStarts->size = new_size;

        ChunkHeader* leftoverChunk = 
        create_leftover_chunk(theHeaderStarts, new_size);

        //that means a left over chunk was made into its own chunk. 
        //return the og ptr
        if(leftoverChunk != NULL){
            return ptr;
        }
        //if it does equal NULL, that means wasn't large enough for min chunk
        //then have to update the size of the chunk
        //leftover size is the chunk size - the new size 
        //the data size is the leftover space

        theHeaderStarts->size = new_size;
    }

    //DO NOTHING:
    //it is the same size so just return the same pointer
    else if (new_size == current_chunk_size) {
        return ptr;
    }

    //GROWING:
    //new size is larger than current and the next one is free
    //and that is large enough
    //combine the chunks, allocate what you need
    //make new chunk with leftover
    //check if other is free next to it
    //combine that too
    //return pointer to first node

    else if(new_size >= current_chunk_size){ //if size is larger than current 


        //check if the next chunk is free and not NULL
        ChunkHeader* nextdoorChunk = theHeaderStarts->next;

        //check if the next chunk is free
        if(nextdoorChunk != NULL && nextdoorChunk->is_it_free == 1){

            //check if combining them will make it large enough
            //then allocate it
            if((current_chunk_size + nextdoorChunk->size + 
                sizeof(ChunkHeader) + 16) >= new_size){
                
                //combine the chunks 
                combine_free_chunks(theHeaderStarts);

                //if there is a leftover part, then make a chunk out of it
                create_leftover_chunk(theHeaderStarts, new_size);
                return ptr;
            }
        }

            //if the next chunk is NULL
            //or if the next chunk is not free
            //or if combining the chunks doesn't make it large enough
            //get more heap
            //combine it with the current chunk
            //create a leftover chunk
            get_more_heap(new_size);
            ChunkHeader* biggerFreeChunk = combine_free_chunks(nextdoorChunk);
            create_leftover_chunk(biggerFreeChunk, new_size);
            return ptr;
        }  
        return NULL;
    }